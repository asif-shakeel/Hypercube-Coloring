hypercube-coloring
==================

This is a program to color the edges of a hypercube. The "colors" for us are integers with 0 represneting a default "uncolored" state of an edge. A proper color is a positive integer, starting with 1 and incrementing by one for the next color etc.  For our purpose we use the following rule.  For a pair of non-adjacent vertices (v1,v2), it requires a  pair of parallel edges in a "separating direction" (defined below) edges e1, e2 , of the same color, incident on v1, v2 respectively. Representing the vertices as binary strings, and identifying directions with the bit positions, a  "separating direction" (or "separating position") for a pair of vertices is a position in which they differ. For instance, in a 3D cube, the vertices  v1=101 and v2=110,  are  "separated" in  directions/positions 0 (LSB) and 1 (counting from right to left). A pair of parallel edges in a separating direction (LSB) would be, for example, e1=(101,100)  incident on v1, and e2=(110,111) incident  on v2. The goal is to find a coloring that is maximal under the following  partial ordering of colorings. Assuming new colors are added from a fixed ordered set (necessarily finite), a coloring C1 is less than another coloring C2 if C1 can be obtained by identifying some of the colors in C2,  under symmetries of the hypercube. This algorithm has an initialization stage, and a coloring stage that recurs until either the algorithm succeeds in coloring the hypercube, or encounters a deadlock it cannot resolve, in which case it aborts. The user can  initialize the algorithm by  user specifying  a set of edges to be colored at the start with an initial set of colors (1 through k, if k initial colors are used) by calling methods within the hypercube object (with obvious names). The doColoring method chooses a direction (0 to n-1) of the hypercube in a round-robin manner, picking a random uncolored edge in that direction and tries to color it with a new color.  For each edge it colors, it checks to make sure the rule is satisfied for each pair of vertices as a result of the added color (calls  the ruleCheck function). This is a "local" as opposed to "global" check,  which would require checking if there are no conflicts between all such pairs of vertices. If nothing is inconsistent, ruleCheck also tries to "fill in" all  the edges that need  to be colored with colors from those already in the hypercube, to stay consitent with the rule.  Then it moves on to the next direction and so on. This is sort of a "greedy algorithm" (though not even locally optimal) in that it only looks at all pairs of vertices and ensures for each pair  the necessary conditions relevant to the pair. It does not guarantee that there are no conflicts between the pairs, which do arise and cause the program to abort. The algorithm implemented is probabilistic and each run yields (with a high probability), a successful coloring of the hypercube, though not always maximal. In general though, it seems to do a good job identifying a possible coloring each run. Needs improvement and generalization.

